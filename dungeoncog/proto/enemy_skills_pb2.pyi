"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class MonsterBehaviorWithOverrides(google.protobuf.message.Message):
    """Persistent output from the processor combined with approval information."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Status:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType  # noqa

    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[MonsterBehaviorWithOverrides._Status.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        NOT_APPROVED: MonsterBehaviorWithOverrides._Status.ValueType  # 0
        """Default status, not reviewed."""
        APPROVED_AS_IS: MonsterBehaviorWithOverrides._Status.ValueType  # 1
        """Reviewed and approved with no changes. If the auto-generated
        behavior changes, updates to NEEDS_REAPPROVAL.
        """
        NEEDS_REAPPROVAL: MonsterBehaviorWithOverrides._Status.ValueType  # 2
        """Was approved in the past but the auto-generated values changed, so
        someone should compare and re-approve.
        """
        APPROVED_WITH_CHANGES: MonsterBehaviorWithOverrides._Status.ValueType  # 3
        """An admin applied changes and then approved the result."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper): ...
    NOT_APPROVED: MonsterBehaviorWithOverrides.Status.ValueType  # 0
    """Default status, not reviewed."""
    APPROVED_AS_IS: MonsterBehaviorWithOverrides.Status.ValueType  # 1
    """Reviewed and approved with no changes. If the auto-generated
    behavior changes, updates to NEEDS_REAPPROVAL.
    """
    NEEDS_REAPPROVAL: MonsterBehaviorWithOverrides.Status.ValueType  # 2
    """Was approved in the past but the auto-generated values changed, so
    someone should compare and re-approve.
    """
    APPROVED_WITH_CHANGES: MonsterBehaviorWithOverrides.Status.ValueType  # 3
    """An admin applied changes and then approved the result."""

    MONSTER_ID_FIELD_NUMBER: builtins.int
    LEVELS_FIELD_NUMBER: builtins.int
    LEVEL_OVERRIDES_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    monster_id: builtins.int
    """The DadGuide unique monster ID."""
    @property
    def levels(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LevelBehavior]:
        """Combination of level value and behaviors at that level."""
    @property
    def level_overrides(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LevelBehavior]:
        """Combination of level value and behaviors at that level."""
    status: global___MonsterBehaviorWithOverrides.Status.ValueType
    """Determines which LevelBehavior should be used.
    If NOT_APPROVED - levels with approved=False
    Anything else - level_overrides with approved=True
    """
    def __init__(
        self,
        *,
        monster_id: builtins.int = ...,
        levels: collections.abc.Iterable[global___LevelBehavior] | None = ...,
        level_overrides: collections.abc.Iterable[global___LevelBehavior] | None = ...,
        status: global___MonsterBehaviorWithOverrides.Status.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["level_overrides", b"level_overrides", "levels", b"levels", "monster_id", b"monster_id", "status", b"status"]) -> None: ...

global___MonsterBehaviorWithOverrides = MonsterBehaviorWithOverrides

@typing_extensions.final
class MonsterBehavior(google.protobuf.message.Message):
    """Monster ID, behaviors per level, and approval status."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MONSTER_ID_FIELD_NUMBER: builtins.int
    LEVELS_FIELD_NUMBER: builtins.int
    APPROVED_FIELD_NUMBER: builtins.int
    monster_id: builtins.int
    """The DadGuide unique monster ID."""
    @property
    def levels(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LevelBehavior]:
        """Combination of level value and behaviors at that level."""
    approved: builtins.bool
    """If this behavior has been approved by a human reviewer."""
    def __init__(
        self,
        *,
        monster_id: builtins.int = ...,
        levels: collections.abc.Iterable[global___LevelBehavior] | None = ...,
        approved: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["approved", b"approved", "levels", b"levels", "monster_id", b"monster_id"]) -> None: ...

global___MonsterBehavior = MonsterBehavior

@typing_extensions.final
class LevelBehavior(google.protobuf.message.Message):
    """Combination of a monster level and the behaviors at that level."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LEVEL_FIELD_NUMBER: builtins.int
    GROUPS_FIELD_NUMBER: builtins.int
    level: builtins.int
    """The level (inclusive) that this behavior executes at."""
    @property
    def groups(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BehaviorGroup]:
        """The behavior at this level."""
    def __init__(
        self,
        *,
        level: builtins.int = ...,
        groups: collections.abc.Iterable[global___BehaviorGroup] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["groups", b"groups", "level", b"level"]) -> None: ...

global___LevelBehavior = LevelBehavior

@typing_extensions.final
class BehaviorGroup(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _GroupType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType  # noqa

    class _GroupTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[BehaviorGroup._GroupType.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNSPECIFIED: BehaviorGroup._GroupType.ValueType  # 0
        """Should not be used"""
        PASSIVE: BehaviorGroup._GroupType.ValueType  # 1
        """Always-active effects."""
        PREEMPT: BehaviorGroup._GroupType.ValueType  # 2
        """Executed on floor entry."""
        DISPEL_PLAYER: BehaviorGroup._GroupType.ValueType  # 3
        """When user has a status effect."""
        MONSTER_STATUS: BehaviorGroup._GroupType.ValueType  # 4
        """When the monster is affected by a status."""
        REMAINING: BehaviorGroup._GroupType.ValueType  # 5
        """When a specific number of enemies are remaining"""
        STANDARD: BehaviorGroup._GroupType.ValueType  # 6
        """Normal group."""
        DEATH: BehaviorGroup._GroupType.ValueType  # 7
        """On monster death."""
        UNKNOWN_USE: BehaviorGroup._GroupType.ValueType  # 8
        """Could not find a slot for these, so dump them all in a separate group."""
        HIGHEST_PRIORITY: BehaviorGroup._GroupType.ValueType  # 9
        """This group will be used before all others."""

    class GroupType(_GroupType, metaclass=_GroupTypeEnumTypeWrapper): ...
    UNSPECIFIED: BehaviorGroup.GroupType.ValueType  # 0
    """Should not be used"""
    PASSIVE: BehaviorGroup.GroupType.ValueType  # 1
    """Always-active effects."""
    PREEMPT: BehaviorGroup.GroupType.ValueType  # 2
    """Executed on floor entry."""
    DISPEL_PLAYER: BehaviorGroup.GroupType.ValueType  # 3
    """When user has a status effect."""
    MONSTER_STATUS: BehaviorGroup.GroupType.ValueType  # 4
    """When the monster is affected by a status."""
    REMAINING: BehaviorGroup.GroupType.ValueType  # 5
    """When a specific number of enemies are remaining"""
    STANDARD: BehaviorGroup.GroupType.ValueType  # 6
    """Normal group."""
    DEATH: BehaviorGroup.GroupType.ValueType  # 7
    """On monster death."""
    UNKNOWN_USE: BehaviorGroup.GroupType.ValueType  # 8
    """Could not find a slot for these, so dump them all in a separate group."""
    HIGHEST_PRIORITY: BehaviorGroup.GroupType.ValueType  # 9
    """This group will be used before all others."""

    GROUP_TYPE_FIELD_NUMBER: builtins.int
    CONDITION_FIELD_NUMBER: builtins.int
    CHILDREN_FIELD_NUMBER: builtins.int
    group_type: global___BehaviorGroup.GroupType.ValueType
    """Type for this group, affects display text and type."""
    @property
    def condition(self) -> global___Condition:
        """Conditions attached to this group executing. Should not be duplicated on
        any child behaviors.
        """
    @property
    def children(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BehaviorItem]:
        """Child behavior items or groups."""
    def __init__(
        self,
        *,
        group_type: global___BehaviorGroup.GroupType.ValueType = ...,
        condition: global___Condition | None = ...,
        children: collections.abc.Iterable[global___BehaviorItem] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["condition", b"condition"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["children", b"children", "condition", b"condition", "group_type", b"group_type"]) -> None: ...

global___BehaviorGroup = BehaviorGroup

@typing_extensions.final
class BehaviorItem(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GROUP_FIELD_NUMBER: builtins.int
    BEHAVIOR_FIELD_NUMBER: builtins.int
    @property
    def group(self) -> global___BehaviorGroup:
        """This item represents a nested group."""
    @property
    def behavior(self) -> global___Behavior:
        """This item represents a terminal behavior."""
    def __init__(
        self,
        *,
        group: global___BehaviorGroup | None = ...,
        behavior: global___Behavior | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["behavior", b"behavior", "group", b"group", "value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["behavior", b"behavior", "group", b"group", "value", b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["value", b"value"]) -> typing_extensions.Literal["group", "behavior"] | None: ...

global___BehaviorItem = BehaviorItem

@typing_extensions.final
class Behavior(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONDITION_FIELD_NUMBER: builtins.int
    ENEMY_SKILL_ID_FIELD_NUMBER: builtins.int
    CHILD_IDS_FIELD_NUMBER: builtins.int
    @property
    def condition(self) -> global___Condition:
        """Conditions associated with this item executing. Should be deduped
        against the parent before display.
        """
    enemy_skill_id: builtins.int
    """The ID of the enemy skill that should be used to populate the item.
    Real monster behaviors start at 1.
    Fake behaviors inserted as a guide start at -1.
    """
    @property
    def child_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The IDs for component skills, if this is a skillset."""
    def __init__(
        self,
        *,
        condition: global___Condition | None = ...,
        enemy_skill_id: builtins.int = ...,
        child_ids: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["condition", b"condition"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["child_ids", b"child_ids", "condition", b"condition", "enemy_skill_id", b"enemy_skill_id"]) -> None: ...

global___Behavior = Behavior

@typing_extensions.final
class Condition(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HP_THRESHOLD_FIELD_NUMBER: builtins.int
    USE_CHANCE_FIELD_NUMBER: builtins.int
    REPEATS_EVERY_FIELD_NUMBER: builtins.int
    GLOBAL_ONE_TIME_FIELD_NUMBER: builtins.int
    LIMITED_EXECUTION_FIELD_NUMBER: builtins.int
    TRIGGER_ENEMIES_REMAINING_FIELD_NUMBER: builtins.int
    IF_DEFEATED_FIELD_NUMBER: builtins.int
    IF_ATTRIBUTES_AVAILABLE_FIELD_NUMBER: builtins.int
    TRIGGER_MONSTERS_FIELD_NUMBER: builtins.int
    TRIGGER_COMBOS_FIELD_NUMBER: builtins.int
    IF_NOTHING_MATCHED_FIELD_NUMBER: builtins.int
    TRIGGER_TURN_FIELD_NUMBER: builtins.int
    TRIGGER_TURN_END_FIELD_NUMBER: builtins.int
    ALWAYS_TRIGGER_ABOVE_FIELD_NUMBER: builtins.int
    ALWAYS_AFTER_FIELD_NUMBER: builtins.int
    SKILL_SET_FIELD_NUMBER: builtins.int
    ERASED_ATTRIBUTES_FIELD_NUMBER: builtins.int
    DAMAGE_DONE_FIELD_NUMBER: builtins.int
    ATTRIBUTES_ATTACKED_FIELD_NUMBER: builtins.int
    SKILLS_USED_FIELD_NUMBER: builtins.int
    hp_threshold: builtins.int
    """Action or group is guarded by a HP threshold."""
    use_chance: builtins.int
    """Action has a % of activating. 0, 100, and missing all mean guaranteed."""
    repeats_every: builtins.int
    """Action/group repeats every N turns."""
    global_one_time: builtins.bool
    """Action/group will only ever execute one time."""
    limited_execution: builtins.int
    """Action/group can execute at most this many times."""
    trigger_enemies_remaining: builtins.int
    """Action/group will only execute when N enemies remain. If this number
    is larger than 10 it should be ignored.
    """
    if_defeated: builtins.bool
    """Action/group will only execute on death of the current monster."""
    if_attributes_available: builtins.bool
    """Action will only execute when specific orbs are available."""
    @property
    def trigger_monsters(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Action/group will execute when specific monsters are on the player's team."""
    trigger_combos: builtins.int
    """Executes if at least this many combos were executed"""
    if_nothing_matched: builtins.bool
    """If this is a fallback skill. Can only be applied manually."""
    trigger_turn: builtins.int
    """Execute if the turn count matches. May be combined with repeats_every
    for actions that repeat in a loop.
    """
    trigger_turn_end: builtins.int
    """If set, the range of turn counts this matches."""
    always_trigger_above: builtins.int
    """Indicates that the trigger turn is absolute for a HP range; that is, it
    will always execute on the trigger_turn when the HP is above this value.

    This should be split out from normal triggers to prevent confusion, and
    those triggers adjusted.

    E.g. if a monster always binds turn 1, and enrages when > 50 on turn 2,
    the first skill should have trigger_turn=1 and always_trigger_above=1,
    while the and enrage should have it's trigger_turn adjusted to 1.
    """
    always_after: builtins.int
    """Indicates that the behavior will always execute after another skill
    identified by this skill id.

    Can only be manually set by an operator.
    """
    skill_set: builtins.int
    """If set on a group, this indicates that the group represents a skillset.
    If set on a behavior, this indicates that the behavior triggers a skillset.
    """
    @property
    def erased_attributes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Execute if the following attributes were erased the previous turn"""
    damage_done: builtins.int
    """execute if we did >= damage"""
    @property
    def attributes_attacked(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """execute if we attacked with the following attributes"""
    skills_used: builtins.int
    """execute if we use >= active skills"""
    def __init__(
        self,
        *,
        hp_threshold: builtins.int = ...,
        use_chance: builtins.int = ...,
        repeats_every: builtins.int = ...,
        global_one_time: builtins.bool = ...,
        limited_execution: builtins.int = ...,
        trigger_enemies_remaining: builtins.int = ...,
        if_defeated: builtins.bool = ...,
        if_attributes_available: builtins.bool = ...,
        trigger_monsters: collections.abc.Iterable[builtins.int] | None = ...,
        trigger_combos: builtins.int = ...,
        if_nothing_matched: builtins.bool = ...,
        trigger_turn: builtins.int = ...,
        trigger_turn_end: builtins.int = ...,
        always_trigger_above: builtins.int = ...,
        always_after: builtins.int = ...,
        skill_set: builtins.int = ...,
        erased_attributes: collections.abc.Iterable[builtins.int] | None = ...,
        damage_done: builtins.int = ...,
        attributes_attacked: collections.abc.Iterable[builtins.int] | None = ...,
        skills_used: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["always_after", b"always_after", "always_trigger_above", b"always_trigger_above", "attributes_attacked", b"attributes_attacked", "damage_done", b"damage_done", "erased_attributes", b"erased_attributes", "global_one_time", b"global_one_time", "hp_threshold", b"hp_threshold", "if_attributes_available", b"if_attributes_available", "if_defeated", b"if_defeated", "if_nothing_matched", b"if_nothing_matched", "limited_execution", b"limited_execution", "repeats_every", b"repeats_every", "skill_set", b"skill_set", "skills_used", b"skills_used", "trigger_combos", b"trigger_combos", "trigger_enemies_remaining", b"trigger_enemies_remaining", "trigger_monsters", b"trigger_monsters", "trigger_turn", b"trigger_turn", "trigger_turn_end", b"trigger_turn_end", "use_chance", b"use_chance"]) -> None: ...

global___Condition = Condition
